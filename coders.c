/*
 Some decoders here ...
*/

//#include "vs.h"
#include "coders.h"
#include <stdarg.h>
#include "vtypes.h"

char *CP_DECODE(char *dst, char *src, int len, char *tbl) {
char *ret = dst;
if (len<0) len = strlen(src);
for( ;len>0;src++,dst++,len--) *dst=tbl[(unsigned char)*src];
*dst=0;
return ret;
}


int hex(unsigned char src) { // Converts char hex representation to a value...
if (src>='0' && src<='9') return src-'0';
if (src>='a' && src<='f') return 10+src-'a';
if (src>='A' && src<='F') return 10+src-'A';
return -1; }


char *url_decode(char *dst, char *src) { // Enocdes %XX and + in a http request headers ...
char *ret = dst;
while(*src) {
 if (*src=='+') *dst=' ';
  else if (*src=='%'&& hex(src[1])>=0 && hex(src[2])>=0)
    {
    int code=hex(src[1])*16+hex(src[2]);
    //if (code==0x85) *dst='.'; else
       *dst=code;
     src+=2;
    }
  else if (*src=='%' && src[1]=='u' && hex(src[2])>=0 && hex(src[3])>=0 && hex(src[4])>=0 && hex(src[5])>=0) {
    // Unicode Convert ...
    uchar wch[2];
    wch[0] = hex(src[4])*16+hex(src[5]);  // Code
    wch[1] = hex(src[2])*16+hex(src[3]);  // Lang
    unicode_to_str(dst,1,wch,2); // ConvertSymbol
    src+=5;
    }
   else *dst=*src;
 dst++; src++;
 }
*dst=0;
return ret;
}

unsigned char rusLetters[33*2+1] = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
                            "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
int rusRating[33*2]={ // Рейтинг использования русских букв
    511,314,634,180,309,131,0,46,186,429,0,494,159,293,610,430,1028,90,371,351,137,505,55,6,151,47,4,0,0,0,645,9,195,22887,4255,12623,4823,8707,24410,0,2828,4821,19135,3662,9803,13939,8149,18652,31353,7771,14089,15345,17512,8648,652,2105,1331,4752,2366,912,103,5092,5252,668,1560,5343
    }; // Акунин, Азазель - http://lib.ru/RUSS_DETEKTIW/BAKUNIN/azazel.txt

int runRatingFill(unsigned char *str) {
int i,j,ok=0;
memset(rusRating,0,sizeof(rusRating));
for(i=0;str[i];i++) {
    for(j=0;j<66;j++) if (rusLetters[j]==str[i]) break;
    if (j>=66) continue;
    ok++; rusRating[j]++; // Считаем сколько в рейтинге
    }
if (ok) for(j=0;j<66;j++) rusRating[j]=(rusRating[j]*10000.)/ok; // Переводим в проценты
// Теперь - печатаем что получилось
for(j=0;j<66;j++) printf("%d,",rusRating[j]);
return 0;
}

int CpGetRate(unsigned char *str, unsigned char *cp) { // Вытаскиваем рейтинг - для указанной перекодировки
double code = 0;// ocode=0;
int i, j , ok = 0;
for(i=0;str[i];i++) {
    unsigned char ch=str[i];
    if (cp) ch=cp[ch];
    for(j=0;j<66;j++) if (rusLetters[j]==ch) break;
    if (j<66) { code+=rusRating[j]; ok++; }
    }
if (!ok) return 0;
printf("Rated=%d\n",i);
return code/ok; // В сотнях процентов
}


char *cp_decode(char *src,char *cp) {
char *r=src;
while(*src) {*src=cp[(unsigned char)*src]; src++;}
return r;
}

/*// TODO (administrator#1#): Разобраться с более быстрой перекодировкой\
русских букв при utf_decode-encode.\
Кажется можно ограничиться обычными массивами\
переменных?
*/



unsigned char dos_win[256]= {
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,
0x91,0x92,0x93,0x94,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa3,0xa5,
0xa6,0xa7,0xab,0xac,0xad,0xae,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xbb,0xbc,0xbd,0xbe,
0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,
0xa8,0xb8,0xaa,0xba,0xaf,0xbf,0xa1,0xa2,0xb0,0x95,0xb7,0xa9,0xb9,0xa4,0x88,0xa0};

unsigned char win_dos[256]= {
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xfe,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,
0xbf,0xc0,0xc1,0xc2,0xc3,0xf9,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,
0xff,0xf6,0xf7,0xce,0xfd,0xcf,0xd0,0xd1,0xf0,0xfb,0xf2,0xd2,0xd3,0xd4,0xd5,0xf4,
0xf8,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xfa,0xf1,0xfc,0xf3,0xdc,0xdd,0xde,0xdf,0xf5,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef};

unsigned char koi_win[256]={
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
0x80,0xa6,0x81,0xac,0x82,0x83,0x84,0x85,0x88,0x89,0x86,0x8a,0x8b,0x8c,0x8d,0x8e,
0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xb0,0x9b,0xb7,0x9c,
0x9d,0x9e,0x9f,0xb8,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa7,0xaa,0xab,0xad,0xae,0xaf,
0xb1,0xb2,0xb3,0xa8,0xb4,0xb5,0xb6,0xb9,0xba,0xbb,0xbc,0xbd,0x87,0xbe,0xbf,0xa9,
0xfe,0xe0,0xe1,0xf6,0xe4,0xe5,0xf4,0xe3,0xf5,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,
0xef,0xff,0xf0,0xf1,0xf2,0xf3,0xe6,0xe2,0xfc,0xfb,0xe7,0xf8,0xfd,0xf9,0xf7,0xfa,
0xde,0xc0,0xc1,0xd6,0xc4,0xc5,0xd4,0xc3,0xd5,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,
0xcf,0xdf,0xd0,0xd1,0xd2,0xd3,0xc6,0xc2,0xdc,0xdb,0xc7,0xd8,0xdd,0xd9,0xd7,0xda};




unsigned char win_koi[256]={
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
0x80,0x82,0x84,0x85,0x86,0x87,0x8a,0xbc,0x88,0x89,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,
0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9d,0x9f,0xa0,0xa1,0xa2,
0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0x81,0xaa,0xb3,0xbf,0xab,0xac,0x83,0xad,0xae,0xaf,
0x9c,0xb0,0xb1,0xb2,0xb4,0xb5,0xb6,0x9e,0xa3,0xb7,0xb8,0xb9,0xba,0xbb,0xbd,0xbe,
0xe1,0xe2,0xf7,0xe7,0xe4,0xe5,0xf6,0xfa,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,
0xf2,0xf3,0xf4,0xf5,0xe6,0xe8,0xe3,0xfe,0xfb,0xfd,0xff,0xf9,0xf8,0xfc,0xe0,0xf1,
0xc1,0xc2,0xd7,0xc7,0xc4,0xc5,0xd6,0xda,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,
0xd2,0xd3,0xd4,0xd5,0xc6,0xc8,0xc3,0xde,0xdb,0xdd,0xdf,0xd9,0xd8,0xdc,0xc0,0xd1
};



u_short win1251_to_unicode[256]={
0x0000,0x0100,0x0200,0x0300,0x0400,0x0500,0x0600,0x0700,
0x0800,0x0900,0x0a00,0x0b00,0x0c00,0x0d00,0x0e00,0x0f00,
0x1000,0x1100,0x1200,0x1300,0x1400,0x1500,0x1600,0x1700,
0x1800,0x1900,0x1a00,0x1b00,0x1c00,0x1d00,0x1e00,0x1f00,
0x2000,0x2100,0x2200,0x2300,0x2400,0x2500,0x2600,0x2700,
0x2800,0x2900,0x2a00,0x2b00,0x2c00,0x2d00,0x2e00,0x2f00,
0x3000,0x3100,0x3200,0x3300,0x3400,0x3500,0x3600,0x3700,
0x3800,0x3900,0x3a00,0x3b00,0x3c00,0x3d00,0x3e00,0x3f00,
0x4000,0x4100,0x4200,0x4300,0x4400,0x4500,0x4600,0x4700,
0x4800,0x4900,0x4a00,0x4b00,0x4c00,0x4d00,0x4e00,0x4f00,
0x5000,0x5100,0x5200,0x5300,0x5400,0x5500,0x5600,0x5700,
0x5800,0x5900,0x5a00,0x5b00,0x5c00,0x5d00,0x5e00,0x5f00,
0x6000,0x6100,0x6200,0x6300,0x6400,0x6500,0x6600,0x6700,
0x6800,0x6900,0x6a00,0x6b00,0x6c00,0x6d00,0x6e00,0x6f00,
0x7000,0x7100,0x7200,0x7300,0x7400,0x7500,0x7600,0x7700,
0x7800,0x7900,0x7a00,0x7b00,0x7c00,0x7d00,0x7e00,0x7f00,

0x0204,0x0304,0x1a20,0x5304,0x1e20,0x2620,0x2020,0x2120,
0xac20,0x3020,0x0904,0x3920,0x0a04,0x0c04,0x0b04,0x0f04,
0x5204,0x1820,0x1920,0x1c20,0x1d20,0x2220,0x1320,0x1420,
0x9800,0x2221,0x5904,0x3a20,0x5a04,0x5c04,0x5b04,0x5f04,
0xa000,0x0e04,0x5e04,0x0804,0xa400,0x9004,0xa600,0xa700,
0x0104,0xa900,0x0404,0xab00,0xac00,0xad00,0xae00,0x0704,
0xb000,0xb100,0x0604,0x5604,0x9104,0xb500,0xb600,0xb700,
0x5104,0x1621,0x5404,0xbb00,0x5804,0x0504,0x5504,0x5704,
0x1004,0x1104,0x1204,0x1304,0x1404,0x1504,0x1604,0x1704,
0x1804,0x1904,0x1a04,0x1b04,0x1c04,0x1d04,0x1e04,0x1f04,
0x2004,0x2104,0x2204,0x2304,0x2404,0x2504,0x2604,0x2704,
0x2804,0x2904,0x2a04,0x2b04,0x2c04,0x2d04,0x2e04,0x2f04,
0x3004,0x3104,0x3204,0x3304,0x3404,0x3504,0x3604,0x3704,
0x3804,0x3904,0x3a04,0x3b04,0x3c04,0x3d04,0x3e04,0x3f04,
0x4004,0x4104,0x4204,0x4304,0x4404,0x4504,0x4604,0x4704,
0x4804,0x4904,0x4a04,0x4b04,0x4c04,0x4d04,0x4e04,0x4F04
};


#define u_char unsigned char
u_char win1251_up[256];

short ntohs2(short src) { // Два байта меняем местами
short res;
uchar *s = (void*)&src,*d = (void*)&res;
d[0]=s[1]; d[1]=s[0];
return res;
}


int str_to_unicode(u_char *wbuf,size_t wsize,u_char *buf,size_t size) {
int i;
  for(i=0;i<size&&i<wsize;i++,buf++,wbuf+=sizeof(u_short))
  {
    *((u_short *)(wbuf))=ntohs2(win1251_to_unicode[*buf]);
  }


return i;
}


int unicode_to_str(char *buf,int size,uchar *wbuf,int wsize) {
int i;
int j;

   for(i=0;i<size&&i<wsize;i++,wbuf+=sizeof(u_short))
   {
     for(j=0;j<256;j++)
     {
        if(ntohs2(win1251_to_unicode[j])==*((u_short *)(wbuf)))
       {
	 break;
       }
     }

     if(j>=256)
     {
       *buf++='?';
     }
     else
     {
       *buf++=(char)(j);
     }
   }


   *buf=0;
   return i;
}




int utf8_peek(char *d,char *s,int l) {
int bit=0,i,byte=0,mask;
//int utf[6]={0x7f,0x7ff,0xffff,0x1fffff,0x3ffffff,0x7fffffff};
if (l<=0) return 0;
for(i=0;i<4;i++) d[i]=0;
for(mask=128,i=0;mask;mask>>=1,i++) if (!(mask&s[0])) break;
if (i==1)  return -1;
if ((i>6)||(i==1)) return -1;
if (i!=0) i--;
if (i+1>l) return -1;  l=i+1; mask>>=1;
switch(i)
{
case 0: byte=0; bit=7; break;
case 1: byte=1; bit=3; break;
case 2: byte=1; bit=8; break;
case 3: byte=3; bit=5; break;
case 4: byte=4; bit=2 ; break;
case 5: byte=4; bit=7 ; break;
}
while(byte>=0)  {
  unsigned char thebyte=0;
  while(bit>0)
   {
   if (mask&(*s))
    {
    thebyte|=(1<<(bit-1));
    }
   bit--; mask>>=1;
   if (mask==0)
      {
      s++; mask=32;
      }
   }
  d[byte]=thebyte; bit=8;
  byte--;
  }
return l;
}

int decode_utf8(char *d,char *s,int sl) {// Results in win1251 ...
char b[8],theb[2];
int k,t,len=0;
if (sl<0) sl = strlen(s);
while(sl>0)
  {
  k=utf8_peek(b,s,sl);
  if (k>0)
     {
     t=unicode_to_str(theb,sizeof(theb),(void*)b,k);
     if (t>0) {if (d) {*d=theb[0]; d++;} len++;}
     } else break;
  s+=k; sl-=k;
  }
if (d) {*d=0;/*if (cp) decode_string(beg,cp); */}
return len;
}

int utf8_poke ( char *utf8char, int wchar, size_t count ) {
	int len=0;

	if (utf8char == NULL)   /* Just determine the required UTF-8 char length. */
	{						/* Ignore count */
		if( wchar < 0 )
			return -1;
		if( wchar < 0x80 )
			return 1;
		if( wchar < 0x800 )
			return 2;
		if( wchar < 0x10000 )
			return 3;
		if( wchar < 0x200000 )
			return 4;
		if( wchar < 0x4000000 )
			return 5;
		if( wchar < 0x80000000 )
			return 6;
		return -1;
	}


	if ( wchar < 0 ) {				/* Invalid wide character */
		len = -1;

	} else if( wchar < 0x80 ) {
		if (count >= 1) {
			utf8char[len++] = (char)wchar;
		}

	} else if( wchar < 0x800 ) {
		if (count >=2) {
			utf8char[len++] = 0xc0 | ( wchar >> 6 );
			utf8char[len++] = 0x80 | ( wchar & 0x3f );
		}

	} else if( wchar < 0x10000 ) {
		if (count >= 3) {
			utf8char[len++] = 0xe0 | ( wchar >> 12 );
			utf8char[len++] = 0x80 | ( (wchar >> 6) & 0x3f );
			utf8char[len++] = 0x80 | ( wchar & 0x3f );
		}

	} else if( wchar < 0x200000 ) {
		if (count >= 4) {
			utf8char[len++] = 0xf0 | ( wchar >> 18 );
			utf8char[len++] = 0x80 | ( (wchar >> 12) & 0x3f );
			utf8char[len++] = 0x80 | ( (wchar >> 6) & 0x3f );
			utf8char[len++] = 0x80 | ( wchar & 0x3f );
		}

	} else if( wchar < 0x4000000 ) {
		if (count >= 5) {
			utf8char[len++] = 0xf8 | ( wchar >> 24 );
			utf8char[len++] = 0x80 | ( (wchar >> 18) & 0x3f );
			utf8char[len++] = 0x80 | ( (wchar >> 12) & 0x3f );
			utf8char[len++] = 0x80 | ( (wchar >> 6) & 0x3f );
			utf8char[len++] = 0x80 | ( wchar & 0x3f );
		}

	} else if( wchar < 0x80000000 ) {
		if (count >= 6) {
			utf8char[len++] = 0xfc | ( wchar >> 30 );
			utf8char[len++] = 0x80 | ( (wchar >> 24) & 0x3f );
			utf8char[len++] = 0x80 | ( (wchar >> 18) & 0x3f );
			utf8char[len++] = 0x80 | ( (wchar >> 12) & 0x3f );
			utf8char[len++] = 0x80 | ( (wchar >> 6) & 0x3f );
			utf8char[len++] = 0x80 | ( wchar & 0x3f );
		}

	} else
		len = -1;

	return len;

}


/* Вот эту штуку и нужно доделать - если чо ... Собстно результат - перекодировка win1251 в UTF8 */
int encode_utf8(char *d,char *s,int sl) { // Results in UTF8 ...
int len = 0; wchar_t w;
if (sl<0) sl = strlen(s);
while (sl>0) {
	int ulen;
	str_to_unicode((unsigned char*)&w,2,(unsigned char *)s,1); // Convert 1 char ...
	ulen = utf8_poke(d,w,100); // Enough space ...
	len+=ulen;
	if (d) d+=ulen; // Move out buf ...
	sl--; s++;
	}
if (d) *d=0; // Zero terminated ...
return len;
}


/// -- base64


unsigned char table_base64[64]=
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";


/*
   Buffers can be the same
   Returns -1 on error (Invalid - not base64 - character)
   ignores \r\n\t...

   Returns dest buffer length
           dest is null-termanated string
*/


int decode_base64(unsigned char *d,unsigned char *s,int slen) {
int len=0,bit=0;
unsigned char b=0, c;
if (slen<0) slen=strlen((char*)s);
while(slen>0)
  {
  int i;
  if (*s=='=') break;
  if (*s>32)
  {
  for(i=0;i<64;i++) if (*s==table_base64[i]) break;
  if (i==64) {
    printf("base64: unk symbol '%c' hex=%d\n",*s,*s);
    return -1;
    }
  c=i;
  for(i=0;i<6;i++,c<<=1)
    {
    b<<=1;
    if (c&32) b|=1;
    bit++;
    if (bit==8) { if (d) *d=b; bit=0; len++; if (d) d++; b=0;}
    }
  }
  s++; slen--;
  }
if (d) *d=0;
return len;
}

/*
   Destination and source buffers CAN NOT be the same,
   SIZES SHOULD BE: sizeof(dest)>2+slen*8/6;
   if slen<0 then slen=strlen(source)
     6->8 bit (3->4 bytes), stopped by '='
   Returns: buffer_length, buffer is null-terminated string

*/

int encode_base64(unsigned char *d,unsigned char *s,int slen)
{
int len=0;  //int mask=128;
if (slen<0)   slen=strlen((char*)s);
while(slen>=3)
  {
  if (d) {
          d[0]=table_base64[s[0]>>2];
          d[1]=table_base64[ ((s[0]&3) <<4) | (s[1]>>4) ];
          d[2]=table_base64[ ((s[1]&15)<<2) | (s[2]>>6) ];
          d[3]=table_base64[ s[2] & 63 ];
          d+=4;
          }
  slen-=3; len+=4; s+=3;
  }
if (slen==1)
  {
  if (d) {
       d[0]=table_base64[s[0]>>2];
       d[1]=table_base64[ ((s[0]&3) <<4)];
       d[2]='=';
       d[3]='=';
       d+=4; }
   len+=4;
   }
if (slen==2)
   {
   if (d) {
          d[0]=table_base64[s[0]>>2];
          d[1]=table_base64[ ((s[0]&3) <<4) | (s[1]>>4) ];
          d[2]=table_base64[ ((s[1]&15)<<2) ];
          d[3]='=';
          d+=4; }
   len+=4;
   }
if (d) *d=0;
return len;
}


int encode_base64_(unsigned char *d,unsigned char *s,int slen)
{
int len=0,i;  int mask=128;
if (slen<0)   slen=strlen((char*)s);
while(slen>0)
  {
  unsigned char b=0;
  for(i=0;i<6;i++)
     {
       b<<=1;
       if ((slen>0)&&(*s&mask)) b|=1;
       mask>>=1;
       if (mask==0)
          {
          s++;
          slen--;
          mask=128;
          }
     }
  *d=table_base64[b];
  d++; len++;
  }
*d=0;
return len;
}


int c_decode(char *d,char *s,int l) {
int c=0;
if (l<0) l=strlen(s);
while(l>0) {
 if (*s=='\\'&&l>1) {
  s++; l--;
  switch(*s) {
   case 't': if (d) *d='\t'; break;
   case 'n': if (d) *d='\n'; break;
   case 'r': if (d) *d='\r'; break;
   case '0': if (d) *d=0;    break;
   default: if (d) *d=*s;
  }
  } else if (d) *d=*s;
 l--; s++; if (d) d++; c++;
 }
if (d) *d=0;
return c;
}

int c_encode(char *r, char *s, int l) {
int i,ll;
if (l<0) l = strlen(s);
ll=l;
for(i=0;i<l;i++) {
 switch(*s) {
 case '\t': if (r) {*r='\\'; r++;  *r='t';} ll++; break;
 case '\n': if (r) {*r='\\'; r++;  *r='n';}; ll++; break;
 case '\r': if (r) {*r='\\'; r++;  *r='r';}; ll++; break;
 case '\\': if (r) {*r='\\'; r++;  *r='\\';}; ll++; break;
 case '\'': if (r) {*r='\\'; r++;  *r='\'';}; ll++; break;
 case '"':  if (r) {*r='\\'; r++;  *r='"';}; ll++; break;
 case 0:    if (r) {*r='\\'; r++;  *r='0';}; ll++; break;
 default: if (r) *r=*s;
 }
 if (r) r++; s++;
 }
if (r) *r=0; // ZeroTerm ...
return ll;
}

int q_encode(char *dst, char *src, int len) { // double print ''
int r = 0;
if (len<0) len = strlen(src);
if (!dst) { for(;*src;src++,r++) if (*src=='\'') r++; return r;}
for(;*src;src++,r++,dst++) {
    if (*src=='\'') { *dst=*src; dst++; r++;}
    *dst = *src;
    }
return r;
}

int vv_printf(char *str, char *fmt, va_list va) { // Обрабатывает %s %q %d %v -- может еще и дату печатать?
int r = 0;
int l; char buf[100], *s;
//printf("vvfmt=<%s>\n",fmt);
for(;*fmt;fmt++) {
    //printf("BEGIN <%s>\n",fmt);
    if (*fmt=='%'  && strchr("sdq",fmt[1])) { // spec case
    fmt++;
    //if (*fmt=='*' &&  fmt[1]=='.' && fmt[2]=='*' && fmt[3]=='s') {        }
    if (*fmt=='s') { s = va_arg(va,char*);

        l=c_encode(str,s,-1); r+=l;
        //if (str) {
          //  printf("\n\nBeforeEncode:<%s>\nAfterEncode<%s>\nl=%d,strlen=%d",s,str,l,strlen(str));
           // }
        if (str) str+=l;

        }
    else if (*fmt=='d') { l = va_arg(va,int); sprintf(buf,"%d",l); l = strlen(buf); r+=l;
                         if (str) { strcpy(str,buf); str+=l;}}
    else if (*fmt=='q') { s = va_arg(va,char*); l=q_encode(str,s,-1); r+=l; if (str) str+=l;}
    }
    else {
    if (str) {*str=*fmt; str++;}
    r++; // JustCopyIt
    }
}
return r;
}

int v_printf(char *str, char *fmt, ...) {
va_list va; int r;
va_start(va,fmt);
r = vv_printf(str,fmt, va);
va_end(va);
return r;
}

uchar unichar(uchar page, uchar code, uchar def) {
uchar uni4[256]={0x00,0xa8,0x80,0x81,0xaa,0xbd,0xb2,0xaf,0xa3,0x8a,0x8c,0x8e,0x8d,0x0d,0xa1,0x8f,0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,0x50,0xb8,0x90,0x83,0xba,0xbe,0xb3,0xbf,0xbc,0x9a,0x9c,0x9e,0x9d,0x5d,0xa2,0x9f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0xa5,0xb4,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff};
uchar uni32[256]={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x96,0x97,0x15,0x16,0x17,0x91,0x92,0x82,0x1b,0x93,0x94,0x84,0x1f,0x86,0x87,0x95,0x23,0x24,0x25,0x85,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x89,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x8b,0x9b,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0x88,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff};
switch(page) {
case 0: return code; // default page
case 4: return uni4[code];; // RusPage -???
case 0x20: return uni32[code]; // punct???
case 0x21: // some specs?
      if (code==0x22) return 153; // TM
      if (code==0x16) return 185; // Number
      return def;
}
return def;
}

int gsm2win(uchar *dst,uchar *src,int len) {
int r = len/2;
if (!dst) return r;
while(len>=2) {
    *dst = unichar(src[0],src[1],'?');
    dst++; src+=2; len-=2;
    }
*dst=0;
return r;
}

int hexstr2bin(char *out,char *in, int len) {
int r=0;
if (len<0) len = strlen(in);
while(len>0) {
    int h = hex(*in),h2;
    len--; in++;
    if (h<0) continue; // skip
    if (len>0) { // try next
        h2 = hex(*in); if (h2>=0) { h=h*16+h2; }
        len--; in++;
        }
    if (out) { *out=h; out++;}
    r++;
    }
if (out) {*out=0;} // terminate
return r;
}

#define ENC(A) (32+(A)) // UU - enc
int encode_uu0(uchar *d, uchar *s, int len) { // 3->4 символа
int r=0;
//if (len>45) len=45; //  Не более 45 букв в строке
//d[0]=ENC(len); d++;  // Каждая строка начинается с длины
r = 4*(len/3);
while(len>=3) { // Целые тройки в целые четверки
    d[0]=ENC(s[0]>>2);
    //printf("d0=%d s[0]=%d s6=%d\n",d[0],s[0],s[0]>>2);
    d[1]=ENC(((s[0]&3) <<4) | (s[1]>>4)) ;
    d[2]=ENC( ((s[1]&15)<<2) | (s[2]>>6)) ;
    d[3]=ENC( s[2] & 63 );
    d+=4; len-=3; s+=3;
  }
switch(len) {
case 1:
       d[0]=ENC(s[0]>>2);
       d[1]=ENC(((s[0]&3) <<4));
       d+=2; r+=2; break;
case 2:
        d[0]=ENC(s[0]>>2);
        d[1]=ENC( ((s[0]&3) <<4) | (s[1]>>4) );
        d[2]=ENC(  ((s[1]&15)<<2) );
        d+=3; r+=3; break;
}
*d=0; // Терминируем
return r; // coded length
}

int encode_uu(uchar *d, uchar *s, int len) { // 3->4 символа + длина строки + переводы строк (не более 61 в строке?)
int r=0,lines;
if (len<0) len = strlen((char*)s);
//if (!d) { // Дефайн длину
    lines = len/45; if (len%45) lines++; // Столько будет линий
    r = 4*(len/3); // Это - тройки в целые четверки четверки
    switch(len%3) { // Есть еще сиволы? -> делаем еще четверку
        case 1: r+=2; break;
        case 2: r+=3; break;
        }
    r+=lines*3; // Для синвола - начала линии, и двух переводов строк
    printf("encode_uu len=%d\n",r);
  if (!d)  return r;
//    }
printf("encode_uu begin code=%d\n",r);
r=0; lines=0;
while(len>0) { // Построчно кодируем
 int l = len,rr;
 if (l>45) l=45;
 d[0]=ENC(l); r++; d++; // Adds a line length
 rr=encode_uu0(d,s,l);

 s+=l; len-=l; d+=rr; r+=rr;
 d[0]='\r'; d[1]='\n'; r+=2; d+=2; // Adds a new liner

 //printf("encode_uu test r=%d\n",r); // 628614
 }
printf("Encode uu_done=%d\n",r);
*d=0;
return r;
}

int win2gsm(uchar *d,uchar *src,int len) {
int r;
if (len<0) len = strlen((char*)src);
r = len*2;
if (!d) return r; // NeedSize
while(len>0) {
    uchar *map;
    map = (void*)(win1251_to_unicode+*src);
    d[0]=map[0]; d[1]=map[1];
    d+=2; len--; src++;
    }
return r;
}


/*
    Привет -> 04 1f 04 40 04 38 04 32 04 35 04 42
*/

int utf2gsm(uchar *d,uchar *src,int len) {
uchar u[8]; int cnt=0;
if (len<0) len=strlen((char*)src);
while (len>0) {
  int l = utf8_peek((char*)u,(char*)src,len);
  if (l<0) break;
  //printf("u0=%d u1=%d u2=%d u3=%d\n",u[0],u[1],u[2],u[3]);
  d[0]=u[1]; d[1]=u[0];
  //d[0]=
  len-=l; src+=l; cnt+=2; d+=2;
  }
return cnt;
}

int utf_nonstd(uchar *src,int len) {
uchar u[8]; int cnt=0;
if (len<0) len=strlen((char*)src);
while (len>0) {
  int l = utf8_peek((char*)u,(char*)src,len);
  if (l<0) break;
  if (u[1]) cnt++; // how many non-en pages?
  //d[0]=
  len-=l; src+=l;
  }
return cnt;
}

int utf2koi(uchar *dst, uchar *src, int len) {
uchar u[8]; int cnt=0;
if (len<0) len=strlen((char*)src);
while (len>0) {
  int l = utf8_peek((char*)u,(char*)src,len);
  if (l<0) break;
  // now - convert unicode->win->koi
  *dst = unichar(u[1],u[0],'?');
  *dst = win_koi[*dst];
  len-=l; src+=l; dst++; cnt++;
  }
*dst=0;
return cnt;
}



#undef ENC






